// ============================================================
//  3.42 — Exemples avancés v2
//  Syntaxe v2 : @ emprunt, - négatif, * neutre, # erreur
// ============================================================


// === A. SYSTÈME D'AUTHENTIFICATION ===

type User {
    id: int;
    name: string;
    email: string;
    role: Role;
    status: trit;     // + = actif, - = banni, * = en attente, # = supprimé
}

type Role = + admin | + moderator | + user | * guest;

type Session {
    token: string;
    user: User;
    expires: timestamp;
}

// Login complet
login = (email: string, password: string) : Session {

    db.find_user(email) {

        user? : {
            verify_password(user@, password@) {

                + : user.status ? {
                    +  : create_session(user);
                    -  : { + error: "Compte banni"; };
                    *  : { + error: "Compte en attente de validation"; };
                    #  : { + error: "Compte supprimé"; };
                };

                - : { + error: "Mot de passe incorrect"; };
            };
        }

        - : { + error: "Utilisateur introuvable"; };
        # : { + error: "Erreur base de données"; };
    };
};

// Utilisation
login("alexis@42.fr", "password123") {
    session? : {
        set_cookie(session.token);
        redirect("/dashboard");
    }
    - err? : show_error(err);
    # : show_error("Erreur système, réessayez plus tard");
};


// === B. API REST COMPLÈTE ===

module api {

    // Middleware — vérifie l'auth avant chaque requête
    auth_middleware = (handler) {
        (request) {
            extract_token(request.headers@) {
                token? : {
                    validate_token(token@) {
                        session? : handler(request, session);
                        - : send_error(401, "Token expiré");
                        # : send_error(401, "Token invalide");
                    };
                }
                _ : send_error(401, "Token manquant");
            };
        };
    };

    // Route GET /users
    get_users = auth_middleware((req, session) {
        session.user.role ? {
            + admin : {
                db.query("SELECT * FROM users")
                    .map(row: User.from(row))
                    .collect() {
                        users? : send_json(users);
                        - err? : send_error(500, err);
                    };
            }
            + moderator : {
                db.query("SELECT * FROM users WHERE active = true")
                    .map(row: User.from(row))
                    .collect() {
                        users? : send_json(users);
                        - err? : send_error(500, err);
                    };
            }
            _ : send_error(403, "Accès refusé");
        };
    });

    // Route POST /users
    create_user = auth_middleware((req, session) {
        session.user.role ? {
            + admin : {
                req.body.parse_json()
                    .validate(User.schema@)
                    .save_to_db() {
                        user? : send_json(user, 201);
                        - err? : send_error(422, err);
                        # : send_error(500, "Erreur interne");
                    };
            }
            _ : send_error(403, "Seul un admin peut créer");
        };
    });
}


// === C. TRAITEMENT DE DONNÉES PARALLÈLE ===

// Pipeline ETL (Extract, Transform, Load)
etl_pipeline = (source: string, dest: string) {

    // Extract — lire les données
    read_csv(source) {

        raw_data? : {
            // Transform — nettoyer et transformer en parallèle
            @parallel
            cleaned = raw_data
                .filter(row: row.is_valid())
                .map(row: normalize(row))
                .map(row: enrich(row));

            // Load — écrire le résultat
            write_to_db(dest, cleaned) {
                count? : print("Chargé " + count + " lignes");
                - err? : print("Échec écriture: " + err);
            };
        }

        - err? : print("Fichier illisible: " + err);
        # : print("Fichier corrompu");
    };
};


// === D. GAME LOOP — boucle de jeu ===

module game {

    type Entity {
        pos: vec2;
        vel: vec2;
        sprite: Texture;
        health: int;
        state: trit;    // + = vivant, - = mort, * = invincible, # = buggé
    }

    update = (entities: list(Entity), dt: float) : list(Entity) {
        @parallel
        entities ? {
            entity? : {
                // Physique
                entity.pos = entity.pos + entity.vel * dt;

                // Collisions
                check_collision(entity@, entities@) {
                    hit? : {
                        entity.health = entity.health - hit.damage;
                        (entity.health <= 0) ? {
                            + : { entity.state = -; }   // mort
                        };
                    }
                    _ : entity;     // pas de collision
                };
            }
            - entity? : entity;     // mort — ne pas mettre à jour
            * entity? : entity;     // invincible — garder tel quel
            # entity? : despawn(entity);  // buggé — supprimer
        };
    };

    render = (entities: list(Entity)@) {
        @gpu
        entities ? {
            entity? : draw(entity.sprite@, entity.pos);
            - entity? : draw(death_anim@, entity.pos);
            * entity? : draw_transparent(entity.sprite@, entity.pos);
        };
    };

    // Main loop
    run = () {
        mut world = init_world();
        mut last_time = now();

        (true) ?? {
            + : {
                dt = now() - last_time;
                last_time = now();

                world.entities = update(world.entities, dt);
                render(world.entities@);

                process_input() {
                    + quit : break;
                    input? : apply_input(world@@, input);
                    _ : {};    // pas d'input
                };
            }
        };
    };
}


// === E. ALGORITHME — Tri fusion (merge sort) ===

merge_sort = (list: list(int)) : list(int) {
    (list.length <= 1) ? {
        + : list;
        - : {
            mid = list.length / 2;
            left = merge_sort(list[..mid]);
            right = merge_sort(list[mid..]);
            merge(left, right);
        }
    };
};

merge = (a: list(int), b: list(int)) : list(int) {
    mut result = [];
    mut i = 0;
    mut j = 0;

    (i < a.length && j < b.length) ?? {
        + : {
            (a[i] <= b[j]) ? {
                + : { result.push(a[i]); i = i + 1; }
                - : { result.push(b[j]); j = j + 1; }
            };
        }
    };

    result + a[i..] + b[j..];
};


// === F. ARBRES — structure récursive / fractale ===

type Tree(T) {
    value: T;
    children: list(Tree(T));
    state: trit;
}

// Parcours en profondeur (DFS)
dfs = (tree: Tree(T)@, action) {
    tree ? {
        node? : {
            action(node.value@);
            node.children ? {
                child? : dfs(child@, action);
            };
        }
        - : {};     // noeud supprimé — ignorer
        * : {};     // noeud vide — ignorer
        # : log("Noeud corrompu détecté");
    };
};

// Recherche
find = (tree: Tree(T)@, predicate) : Tree(T) {
    tree ? {
        node? (predicate(node.value@)) : node;
        node? : {
            node.children
                .map(child: find(child@, predicate))
                .filter(result: result.?) {
                    found? : found.first();
                    _ : *;     // non trouvé → neutre
                };
        }
    };
};


// === G. STREAM PROCESSING — données temps réel ===

@async
process_stream = (source: Stream) {

    source ?? {
        event? : {
            // Classifier l'événement par pattern matching
            event.type ? {
                + "click"    : track_click(event);
                + "purchase" : {
                    validate_purchase(event.data@) {
                        order? : {
                            @parallel
                            [
                                charge_payment(order@),
                                send_confirmation(order@),
                                update_inventory(order@)
                            ] ? {
                                results? : commit(results);
                                - err? : rollback(order, err);
                            };
                        }
                        - err? : log_invalid(err);
                    };
                }
                + "signup"   : create_account(event.data);
                _            : log("Événement inconnu: " + event.type);
            };
        }
        - err? : reconnect(source@@);
        # : { log_critical("Stream corrompu"); break; };
    };
};


// === H. MACHINE LEARNING — réseau de neurones simple ===

module nn {

    type Layer {
        weights: matrix;
        biases: vector;
        activation: (float) : float;
    }

    type Network {
        layers: list(Layer);
    }

    forward = (net: Network@, input: vector) : vector {
        mut current = input;
        net.layers ? {
            layer? : {
                current = layer.weights
                    .dot(current)
                    .add(layer.biases@)
                    .map(x: layer.activation(x));
            }
        };
        current;
    };

    train = (net: Network@@, data: list((vector, vector))@, epochs: int) {
        range(0, epochs) ? {
            epoch? : {
                mut total_loss = 0.0;

                @parallel
                data ? {
                    (input?, expected?) : {
                        output = forward(net@, input);
                        loss = mse(output, expected@);
                        total_loss = total_loss + loss;
                        gradients = backprop(net@, input@, expected@);
                        apply_gradients(net@@, gradients@);
                    }
                };

                print("Epoch " + epoch + " — Loss: " + total_loss / data.length);
            }
        };
    };
}


// === I. FINANCE — analyse de portefeuille ===

module finance {

    type Asset {
        symbol: string;
        price: float;
        volume: int;
        trend: trit;    // + = hausse, - = baisse, * = stable, # = données invalides
    }

    analyze_portfolio = (assets: list(Asset)@) {
        assets ? {
            asset? : {
                asset.trend ? {
                    + : print(asset.symbol + " ↑ " + asset.price);
                    - : print(asset.symbol + " ↓ " + asset.price);
                    * : print(asset.symbol + " → " + asset.price);
                    # : print(asset.symbol + " ⚠ données corrompues");
                };
            }
        };

        // Stats agrégées
        up = assets.filter(a: a.trend == +).length;
        down = assets.filter(a: a.trend == -).length;
        print("Hausse: " + up + " | Baisse: " + down);
    };

    // Simulation Monte Carlo avec prob
    use math::probability { normal };

    simulate = (asset: Asset@, days: int, simulations: int) {
        @parallel
        range(0, simulations) ? {
            sim? : {
                mut price = asset.price;
                range(0, days) ? {
                    day? : {
                        change = normal(0.0, 0.02);    // volatilité 2%
                        price = price * (1.0 + change);
                    }
                };
                price;
            }
        };
    };
}


// === J. BIOINFORMATIQUE — analyse de séquences ===

@extend biology {

    type Codon = string;    // triplet de nucléotides
    type Sequence = list(Codon);

    translate = (seq: Sequence@) : list(string) {
        seq ? {
            codon? : {
                codon_table[codon] {
                    amino? : amino;
                    - : "?";    // codon inconnu
                    # : "X";    // codon invalide
                };
            }
        };
    };

    find_motif = (seq: Sequence@, pattern: string) : list(int) {
        mut positions = [];
        seq ? {
            codon?, i : {
                (codon.matches(pattern@)) ? {
                    + : positions.push(i);
                };
            }
        };
        positions;
    };
}

@biology
dna = load_fasta("genome.fasta");
proteins = translate(dna@);
atg_positions = find_motif(dna@, "ATG");

proteins ? {
    protein? : {
        analyze_structure(protein@) {
            structure? : visualize(structure);
            - : print("Repliement impossible");
            # : print("Séquence corrompue");
        };
    }
};
