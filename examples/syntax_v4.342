// ============================================================
//  3.42 — Exemples de syntaxe v4
//  ÉMERGENCE TOTALE — 7 quarks + 5 spins → tout émerge
//  | = pipe SPSC, ~ = broadcast SPMC
//  Zéro annotation d'exécution
//  Quantum gates et math → modules (pas built-in)
// ============================================================


// === 1. HELLO WORLD ===

main = () {
    print("Hello, 3.42!");
};


// === 2. VARIABLES — nommer des sphères ===

name = "Alexis";
age = 23;
mut count = 0;
pi_approx = 3.14159;


// === 3. FONCTIONS — sphères qui transforment ===

greet = (name: string) : string {
    "Hello {name}";
};

add = (a: int, b: int) : int {
    a + b;
};

message = greet("Alexis");
result = add(2, 3);


// === 4. CONDITIONNEL — mesure unique ===

// Simple (= if)
(age > 18) ? {
    + : welcome();
};

// Avec négatif (= if/else)
(age > 18) ? {
    + : welcome();
    - : refuse();
};

// Inline après expression (? implicite)
check_permission(user) {
    + : grant_access();
    - : deny_access();
    # : log_critical();
};


// === 5. ITÉRATION — mesure sur collection ===

// Foreach simple
users ? {
    item? : greet(item);
};

// Avec filtre
users ? {
    user? (user.age > 18) : welcome(user);
};

// Scan — chaque élément trié par spin
results ? {
    + item? : process(item);
    - item? : recover(item);
    * item? : skip;
    # item? : quarantine(item);
};


// === 6. BOUCLE — mesure continue ===

// While
mut count = 10;
(count > 0) ?? {
    + : {
        process(count);
        count = count - 1;
    }
};

// Boucle infinie
(true) ?? {
    + : {
        sensor.read() {
            data? : process(data);
            - err? : alert(err);
            # : break;
        };
    }
};

// Range NATIF
0..100 ? {
    i? : compute(i);
};


// === 7. CHAÎNAGE UFCS + BLOC DE MESURE ===

// Séquentiel (avec .)
data.filter(x: x > 0)
    .map(x: x * 2)
    .collect() {
        result? : save(result);
        - : use_default();
    };

// Propagation auto + mesure à la fin
user.profile.avatar.url {
    url? : display_image(url);
    - : display_placeholder();
    # : log("avatar corrompu");
};


// === 8. PIPE — parallélisme émergent ===

// Pipeline parallèle (chaque | = green thread + SPSC buffer)
big_data | heavy_compute | save_results;

// Pipeline avec transformation
raw_data
    | filter(row: row.is_valid())
    | map(row: normalize(row))
    | write_to_db;

// GPU émergent : le scheduler détecte collection uniforme → GPU auto
pixels | shade | composite;

// Async émergent : le scheduler détecte I/O → non-blocking auto
requests ?? {
    req? : req;
} | handle | send_response;


// === 9. BROADCAST — diffusion 1→N ===

// Un producteur, trois consommateurs
event_stream ~ [logger, analytics, alerter];

// Avec pipelines par branche
events ~ [
    filter(e: e.level == "error") | alert,
    filter(e: e.type == "metric") | dashboard,
    archive
];


// === 10. MODULES ===

module math {
    circle_area = (r: float) : float {
        math::pi * r * r;
    };
}

area = math::circle_area(5.0);


// === 11. TYPES ===

// Inféré
x = 42;
name = "Alice";

// Explicite
x: int = 42;

// Struct
type Point {
    x: float;
    y: float;
}

// Enum (variantes avec spin)
type Color = + red | + green | + blue | * none;

p = Point { x: 1.0, y: 2.0 };
c: Color = + red;

c ? {
    + red   : draw_red();
    + green : draw_green();
    + blue  : draw_blue();
    _       : draw_default();
};


// === 12. GESTION D'ERREURS — native via spin ===

read_file = (path: string) : string {
    // Retourne spin via le contenu
};

read_file("data.txt") {
    content? : {
        parse_json(content) {
            data? : process(data);
            - err? : print("JSON invalide: {err}");
        };
    }
    - err? : print("Fichier introuvable: {err}");
    # : print("Erreur système critique");
};

// Return avec spin explicite
safe_divide = (a: float, b: float) : float {
    (b == 0.0) ? {
        + : return - "division par zéro";
    };
    a / b;
};


// === 13. MÉMOIRE — emprunt avec @ et @@ ===

send(data);                 // move : data n'existe plus
print(data@);               // emprunt lecture : data reste
modify(data@@);             // emprunt écriture : exclusif
backup = copy(data);        // copie explicite

display = (item: Point@) : string {
    "({item.x}, {item.y})";
};

transform = (item: Point@@) {
    item.x = item.x * 2;
    item.y = item.y * 2;
};


// === 14. MAPS ET LISTES ===

numbers = [1, 2, 3, 4, 5];
config = ["host" : "localhost", "port" : 8080];
host = config["host"];

// Slices
first_three = numbers[0..3];
from_second = numbers[1..];


// === 15. STREAMS INFINIS ===

// pi comme flux de décimales (depuis module math)
mut digit_count = 0;
math::pi ?? {
    digit? : {
        print(digit);
        digit_count = digit_count + 1;
        (digit_count > 50) ? {
            + : break;
        };
    }
};

first_100 = math::pi.take(100).collect();
area = math::pi * r * r;     // précision auto


// === 16. DESTRUCTURING ===

(x, y) = get_position();
[first, second, ...rest] = get_items();


// === 17. GENERICS ===

type Box(T) {
    value: T;
}

identity = (x: T) : T { x; };

sort = (list: list(T : Comparable)) : list(T) {
    // tri générique
};


// === 18. TRAITS ===

trait Comparable(T) {
    cmp = (other: T@) : int;
}

Point : Comparable(Point) {
    cmp = (other: Point@) : int {
        // self = binding implicite (pas un keyword)
        dist_self = math::sqrt(self.x * self.x + self.y * self.y);
        dist_other = math::sqrt(other.x * other.x + other.y * other.y);
        dist_self - dist_other;
    };
}


// === 19. FIZZBUZZ ===

1..101 ? {
    n? : n ? {
        (n % 15 == 0) : print("FizzBuzz");
        (n % 3 == 0)  : print("Fizz");
        (n % 5 == 0)  : print("Buzz");
        _             : print(n);
    }
};


// === 20. SERVEUR HTTP ===

// Le scheduler détecte I/O dans handle → non-blocking automatique
server = listen(8080);

server ?? {
    request? : {
        request.path ? {
            + "/home" : send_html(home_page());
            + "/api"  : request.body
                            .parse_json()
                            .validate()
                            .process() {
                                data? : send_json(data);
                                - err? : send_error(400, err);
                            };
            _ : send_error(404, "Not found");
        };
    }
    - err? : log("Connexion échouée: {err}");
};


// === 21. PROBABILITÉ NATIVE ===

// Littéral avec suffixe p
coin = 0.5p;
coin ? {
    + : print("pile");
    - : print("face");
};

// Distribution (depuis module math)
dice = math::uniform(1, 6);
dice ? {
    result? : print("Lancé: {result}");
};

// Opérations probabilistes
both = p1 && p2;        // intersection
either = p1 || p2;      // union
inverse = !p1;           // complémentaire


// === 22. QUANTIQUE NATIF ===

use quantum;

// Créer un qubit (spin * = superposition)
q = qubit();

// Portes quantiques (depuis module quantum)
q = quantum::H(q);               // Hadamard → superposition 50/50

// Mesure = ? (le paradigme EST quantique)
q ? {
    + : print("spin up");
    - : print("spin down");
};

// Intrication
q1 = qubit();
q2 = qubit();
q1 = quantum::H(q1);
quantum::CNOT(q1, q2);           // q1 et q2 intriqués

// Mesurer q1 collapse aussi q2
q1 ? {
    + : print("q1 up → q2 up");
    - : print("q1 down → q2 down");
};

// Circuit quantique
// Pas de @qpu — le compilateur détecte qubit → route auto vers QPU
teleport = (data: qubit) : qubit {
    alice = qubit();
    bob = qubit();
    alice = quantum::H(alice);
    quantum::CNOT(alice, bob);          // paire EPR
    quantum::CNOT(data, alice);
    data = quantum::H(data);

    data ? {
        + : quantum::X(bob);
    };
    alice ? {
        + : quantum::Z(bob);
    };

    bob;
};

// Sans QPU → simulation locale auto (jusqu'à ~30 qubits)
simulate_bell = () {
    q1 = qubit();
    q2 = qubit();
    q1 = quantum::H(q1);
    quantum::CNOT(q1, q2);

    mut stats = ["++" : 0, "+-" : 0, "-+" : 0, "--" : 0];
    0..1000 ? {
        run? : {
            r1 = q1 ?;
            r2 = q2 ?;
        }
    };
};


// === 23. PIPE vs UFCS — quand utiliser quoi ===

// UFCS (.) = séquentiel, même thread, chaînage fluide
data.filter(x: x > 0).map(x: x * 2).save();

// Pipe (|) = parallèle, threads séparés, ring buffer SPSC
data | filter(x: x > 0) | map(x: x * 2) | save;

// Combinaison : UFCS dans chaque étage du pipe
raw | parse.validate().normalize() | store;
