// ============================================================
//  3.42 — Exemples de syntaxe v3
//  TOUT EST NATIF — Pas de stdlib — C = linkage uniquement
//  Spins : + (positif) - (négatif) * (neutre) # (erreur)
//  _ = wildcard, @ = emprunt lecture, @@ = emprunt écriture
//  0.5p = probabilité, qubit() = quantique, 0..100 = range
// ============================================================


// === 1. HELLO WORLD ===

main = () {
    print("Hello, 3.42!");
};


// === 2. VARIABLES — nommer des sphères ===

name = "Alexis";
age = 23;
mut count = 0;
pi_approx = 3.14159;


// === 3. FONCTIONS — sphères qui transforment ===

greet = (name: string) : string {
    "Hello {name}";
};

add = (a: int, b: int) : int {
    a + b;
};

message = greet("Alexis");
result = add(2, 3);


// === 4. CONDITIONNEL — mesure unique ===

// Simple (= if)
(age > 18) ? {
    + : welcome();
};

// Avec négatif (= if/else)
(age > 18) ? {
    + : welcome();
    - : refuse();
};

// Inline après expression (? implicite)
check_permission(user) {
    + : grant_access();
    - : deny_access();
    # : log_critical();
};


// === 5. ITÉRATION — mesure sur collection ===

// Foreach simple
users ? {
    item? : greet(item);
};

// Avec filtre
users ? {
    user? (user.age > 18) : welcome(user);
};

// Scan — chaque élément trié par spin
results ? {
    + item? : process(item);
    - item? : recover(item);
    * item? : skip;
    # item? : quarantine(item);
};


// === 6. BOUCLE — mesure continue ===

// While
mut count = 10;
(count > 0) ?? {
    + : {
        process(count);
        count = count - 1;
    }
};

// Boucle infinie
(true) ?? {
    + : {
        sensor.read() {
            data? : process(data);
            - err? : alert(err);
            # : break;
        };
    }
};

// Range NATIF (pas de fonction, pas de stdlib)
0..100 ? {
    i? : compute(i);
};


// === 7. CHAÎNAGE UFCS + BLOC DE MESURE ===

data.filter(x: x > 0)
    .map(x: x * 2)
    .collect() {
        result? : save(result);
        - : use_default();
    };

// Propagation auto + mesure à la fin
user.profile.avatar.url {
    url? : display_image(url);
    - : display_placeholder();
    # : log("avatar corrompu");
};


// === 8. PARALLÉLISME — annotation ===

@parallel
big_data ? {
    chunk? : heavy_compute(chunk);
};

@gpu
pixels ? {
    px? : shade(px);
};

@async
requests ? {
    req? : handle(req) {
        response? : send(response);
        - timeout? : retry(req);
        # : close_connection();
    };
};


// === 9. MODULES ===

module math {
    circle_area = (r: float) : float {
        pi * r * r;     // pi = stream natif, précision auto
    };

    sin = (x: float) : float {
        // implémentation native (Taylor series)
    };
}

area = math::circle_area(5.0);


// === 10. TYPES ===

// Inféré
x = 42;
name = "Alice";

// Explicite
x: int = 42;

// Struct
type Point {
    x: float;
    y: float;
}

// Enum (variantes avec spin)
type Color = + red | + green | + blue | * none;

p = Point { x: 1.0, y: 2.0 };
c: Color = + red;

c ? {
    + red   : draw_red();
    + green : draw_green();
    + blue  : draw_blue();
    _       : draw_default();
};


// === 11. GESTION D'ERREURS — native via spin ===

read_file = (path: string) : string {
    // Retourne spin via le contenu
    // Le compilateur détecte si la fonction peut échouer
};

read_file("data.txt") {
    content? : {
        parse_json(content) {
            data? : process(data);
            - err? : print("JSON invalide: {err}");
        };
    }
    - err? : print("Fichier introuvable: {err}");
    # : print("Erreur système critique");
};

// Return avec spin explicite
safe_divide = (a: float, b: float) : float {
    (b == 0.0) ? {
        + : return - "division par zéro";
    };
    a / b;
};


// === 12. MÉMOIRE — emprunt avec @ et @@ ===

send(data);                 // move : data n'existe plus
print(data@);               // emprunt lecture : data reste
modify(data@@);             // emprunt écriture : exclusif
backup = copy(data);        // copie explicite

display = (item: Point@) : string {
    "({item.x}, {item.y})";
};

transform = (item: Point@@) {
    item.x = item.x * 2;
    item.y = item.y * 2;
};


// === 13. MAPS ET LISTES ===

numbers = [1, 2, 3, 4, 5];
config = ["host" : "localhost", "port" : 8080];
host = config["host"];

// Slices
first_three = numbers[0..3];
from_second = numbers[1..];


// === 14. STREAMS INFINIS ===

// pi comme flux de décimales
pi ?? {
    digit? : {
        print(digit);                   // 3, 1, 4, 1, 5, 9...
        (digit_index > 50) ? {
            + : break;
        };
    }
};

first_100 = pi.take(100).collect();
area = pi * r * r;     // précision auto


// === 15. DESTRUCTURING ===

(x, y) = get_position();
[first, second, ...rest] = get_items();


// === 16. GENERICS ===

type Box(T) {
    value: T;
}

identity = (x: T) : T { x; };

sort = (list: list(T : Comparable)) : list(T) {
    // tri générique
};


// === 17. TRAITS ===

trait Comparable(T) {
    cmp = (other: T@) : int;
}

Point : Comparable(Point) {
    cmp = (other: Point@) : int {
        distance(self) - distance(other);
    };
}


// === 18. FIZZBUZZ ===

1..101 ? {
    n? : n ? {
        (n % 15 == 0) : print("FizzBuzz");
        (n % 3 == 0)  : print("Fizz");
        (n % 5 == 0)  : print("Buzz");
        _             : print(n);
    }
};


// === 19. SERVEUR HTTP ===

@async
server = listen(8080);

server ?? {
    request? : {
        request.path ? {
            + "/home" : send_html(home_page());
            + "/api"  : request.body
                                    .parse_json()
                                    .validate()
                                    .process() {
                                        data? : send_json(data);
                                        - err? : send_error(400, err);
                                    };
            _ : send_error(404, "Not found");
        };
    }
    - err? : log("Connexion échouée: {err}");
};


// === 20. PROBABILITÉ NATIVE ===

// Littéral avec suffixe p
coin = 0.5p;
coin ? {
    + : print("pile");
    - : print("face");
};

// Distribution native (built-in, pas de stdlib)
dice = uniform(1, 6);
dice ? {
    result? : print("Lancé: {result}");
};

// Opérations probabilistes
both = p1 && p2;        // intersection
either = p1 || p2;      // union
inverse = !p1;           // complémentaire


// === 21. QUANTIQUE NATIF ===

// Créer un qubit (spin * = superposition)
q = qubit();

// Portes quantiques (built-in)
q = H(q);               // Hadamard → superposition 50/50

// Mesure = ? (le paradigme EST quantique)
q ? {
    + : print("spin up");
    - : print("spin down");
};

// Intrication
q1 = qubit();
q2 = qubit();
q1 = H(q1);
CNOT(q1, q2);           // q1 et q2 intriqués

// Mesurer q1 collapse aussi q2
q1 ? {
    + : print("q1 up → q2 up");
    - : print("q1 down → q2 down");
};

// Circuit quantique sur QPU distant
@qpu("ibm_eagle")
teleport = (data: qubit) : qubit {
    alice = qubit();
    bob = qubit();
    alice = H(alice);
    CNOT(alice, bob);           // paire EPR
    CNOT(data, alice);
    data = H(data);

    // Mesures classiques
    data ? {
        + : X(bob);
    };
    alice ? {
        + : Z(bob);
    };

    bob;    // bob contient maintenant l'état de data
};

// Sans @qpu → simulation locale auto (jusqu'à ~30 qubits)
simulate_bell = () {
    q1 = qubit();
    q2 = qubit();
    q1 = H(q1);
    CNOT(q1, q2);

    // 1000 mesures pour vérifier la corrélation
    mut stats = ["++ " : 0, "+- " : 0, "-+ " : 0, "-- " : 0];
    0..1000 ? {
        run? : {
            // Chaque mesure collapse indépendamment
            r1 = q1 ?;
            r2 = q2 ?;
            // Mettre à jour stats...
        }
    };
};
