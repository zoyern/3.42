# ============================================================
#  3.42 — Grammaire PEG Formelle — Checkpoint CP-2
#  "19 bosons. 5 gluons. 4 spins. 1 règle. Tout émerge."
#
#  PARADIGME : MODÈLE PARTICULES
#    Fermions = données (valeurs, expressions)
#    Bosons = opérations (19 symboles-forces)
#    Gluons = conteneurs ({} () [] "" '')
#    Règle : Boson(X) = appliquer la force sur X
#
#  19 BOSONS :
#    < SORTIR      > ENTRER       . ACCÉDER     ? MESURER
#    ! INVERSER    | CONNECTER    ~ DIFFUSER    ^ SUPERPOSER
#    % PROPORTIONNER              / DIVISER
#    : DÉFINIR     = LIER         ; TERMINER    + ACCUMULER
#    - RÉDUIRE     * TRANSFORMER  # MARQUER     _ IGNORER
#    @ RÉFÉRENCER
#
#  TRIO COMPUTE : | CPU, ~ GPU, ^ QPU
#
#  4 SPINS (2 bits) : + (positif) - (négatif) # (erreur) _ (void)
#  * = flag "any" (wildcard en pattern, boson TRANSFORMER sinon)
#
#  AGNOSTICISME COMPUTE :
#    Binary  (2 bits)  : + = 00, - = 01, # = 10, _ = 11
#    Ternary (2 trits) : + = (+,+), - = (+,-), # = (-,+), _ = (-,-)
#    Quantum (1 qubit) : + = |0⟩, - = |1⟩, # = |err⟩, _ = |void⟩
#    Le code 342 reste identique. Backend choisit l'encoding.
#
#  KEYWORDS : 2 base + 6 sucre
#    base  : type, trait
#    sucre : true(+), false(-), void(_), any(*),
#            continue(>>), defer(!?)
#
#  CHANGEMENTS CP-1 → CP-2 :
#    / ajouté       : 19ème boson DIVISER (division, commentaires émergent)
#    // émerge      : DIVISER(DIVISER) = séparer du code = commentaire
#    /* */ émerge   : DIVISER + gluon = bloc commentaire
#    Agnosticisme   : bit/trit/qbit configurable au backend
#    Traçabilité    : 342 → AST → 342-IR → LLVM IR → Assembly → Binaire
#    Compositions N : profondeur arbitraire (pas limité à 4)
#
#  HÉRITAGE complet :
#    v5: module(::) return(<<) break(><) mut(~) copy(**) cast(:>)
#    v6: {} universel, a..b range, ..field parent, a >< b pass-through
#    v7: ''(raw) >>(continue) !?(defer) sugar keywords
#    v8: ^(QPU) ^{}(quantum block) ^^(quantum measure)
#    CP-1: %(proportion) $(interpolation) 4 spins(2-bit)
#    CP-2: /(diviser) commentaires émergents, agnosticisme compute
# ============================================================
#
#  Convention PEG :
#    /     = choix ordonné (essaie gauche d'abord)
#    *     = zéro ou plus
#    +     = un ou plus
#    ?     = optionnel
#    !     = négation (lookahead négatif)
#    &     = lookahead positif
#    'x'   = terminal littéral
#    [a-z] = classe de caractères
#    <- ou = = définition de règle
#

# ============================================================
#  PROGRAMME
# ============================================================

Program          <- Spacing (Statement Spacing)* EOF

# ============================================================
#  STATEMENTS (instructions)
# ============================================================

Statement        <- ModuleDecl
                  / TypeDecl
                  / TraitDecl
                  / ImplDecl
                  / ExtendDecl
                  / AnnotatedStatement
                  / DestructAssign
                  / MutDecl
                  / ReturnStmt
                  / BreakStmt
                  / ContinueSugar
                  / ContinueStmt
                  / DeferSugar
                  / DeferStmt
                  / QuantumBlock
                  / Assignment
                  / ExpressionStmt

# v8.0 NOUVEAU — ^ = SUPERPOSER = QPU boson (17ème)
# ^{} = bloc quantique : contenu en superposition
# ^^ = mesure quantique (collapse de la superposition)
# Trio compute unifié : | CPU (connecter), ~ GPU (diffuser), ^ QPU (superposer)
# CPU : pas d'équivalent direct (concept quantique)
# Classique : simule via probabilités ou tenseurs
# Émergence : SUPERPOSER = maintenir plusieurs états simultanés
# ^{a, b, c} = superposition de a, b, c
# ^^expr = mesurer/collapser expr (choisir un état)
QuantumBlock     <- '^' Spacing '{' Spacing (Statement Spacing)* Expression? Spacing '}'
QuantumMeasure   <- '^^' Spacing UnaryExpr

# v5.0 : module → ::name {}
# '::' en début de statement = déclaration module
# '::' entre identifiers (a::b) = chemin (expression)
ModuleDecl       <- '::' Spacing Identifier Spacing
                    '{' Spacing (Statement Spacing)* '}'

TypeDecl         <- 'type' Spacing Identifier GenericParams? Spacing TypeBody

GenericParams    <- '(' Spacing GenericParam (Spacing ',' Spacing GenericParam)* Spacing ')'
GenericParam     <- Identifier (Spacing ':' Spacing TraitBound)?
TraitBound       <- TypePath (Spacing '+' Spacing TypePath)*

TypeBody         <- '{' Spacing (FieldDecl Spacing)* '}'
                  / '=' Spacing VariantList
                  / ':' Spacing TraitBound Spacing '{' Spacing (Statement Spacing)* '}'

FieldDecl        <- Identifier Spacing ':' Spacing TypeExpr Semicolon

VariantList      <- Variant (Spacing '|' Spacing Variant)*
Variant          <- SpinPattern? Spacing Identifier
                    ('(' Spacing TypeList? Spacing ')')?

# --- TRAITS (interfaces / contrats de comportement) ---

TraitDecl        <- 'trait' Spacing Identifier GenericParams? Spacing
                    '{' Spacing (TraitMethod Spacing)* '}'

TraitMethod      <- Identifier Spacing '=' Spacing
                    '(' Spacing ParamList? Spacing ')'
                    (Spacing ':' Spacing TypeExpr)? Semicolon

# --- IMPL (implémentation de trait pour un type) ---
# self = binding implicite (le compilateur l'injecte comme @ à l'instance)

ImplDecl         <- Identifier Spacing ':' Spacing TypePath Spacing
                    '{' Spacing (Statement Spacing)* '}'

# --- DESTRUCTURING ---

DestructAssign   <- TupleDestructure / ListDestructure

TupleDestructure <- '(' Spacing Identifier (Spacing ',' Spacing Identifier)* Spacing ')'
                    Spacing '=' Spacing Expression Semicolon

ListDestructure  <- '[' Spacing Identifier (Spacing ',' Spacing Identifier)*
                    (Spacing ',' Spacing '...' Identifier)? Spacing ']'
                    Spacing '=' Spacing Expression Semicolon

ExtendDecl       <- '@extend' Spacing Identifier Spacing
                    '{' Spacing (Statement Spacing)* '}'

# Annotations : UNIQUEMENT @extend et @comptime
AnnotatedStatement <- Annotation+ Spacing Statement
Annotation       <- '@' Identifier ('(' Spacing ArgList? Spacing ')')? Spacing

# Assignment APRÈS MutDecl dans l'ordre des alternatives
# car MutDecl <- '~' Spacing Assignment et ~ ne matche pas Assignment
Assignment       <- Identifier Spacing (':' Spacing TypeExpr Spacing)?
                    '=' Spacing Expression Semicolon

# ~ remplace mut
MutDecl          <- '~' Spacing Assignment

# << remplace return
# En début de statement = return
# SpinReturn optionnel : << + expr; (retourne spin +)
ReturnStmt       <- '<<' Spacing SpinReturn? Spacing Expression? Semicolon
SpinReturn       <- SpinPattern !'='

# v6.0 : >< remplace >> pour break
# >< = ENTRER(SORTIR) = entrer dans la sortie = quitter le contexte
# Supporte spin + valeur (comme return) :
#   >< ;           → break simple
#   >< + result ;  → break avec valeur positive
#   >< # err ;     → break avec erreur
#   >< expr ;      → break avec valeur (spin + par défaut)
BreakStmt        <- '><' Spacing SpinReturn? Spacing Expression? Semicolon

# v7.0 NOUVEAU — >> = continue = ENTRER(ENTRER) = re-entrer dans la boucle
# CPU : JMP LOOP_START (saut inconditionnel vers le début de la boucle)
# Émergence : ENTRER appliqué à ENTRER = re-entrer = recommencer l'itération
# Supporte spin optionnel (rare mais cohérent) :
#   >> ;           → continue simple (skip to next iteration)
#   >> + ;         → continue avec signal positif (filter pattern)
# Sucre : continue = >>
# Sucre : continue = >> (keyword → symbole)
ContinueSugar    <- 'continue' ![a-zA-Z0-9_] Spacing SpinReturn? Spacing Expression? Semicolon
ContinueStmt     <- '>>' !'=' Spacing SpinReturn? Spacing Expression? Semicolon

# v7.0 NOUVEAU — !? = defer = INVERSER(MESURER) = évaluer plus tard
# CPU : PUSH cleanup_addr sur defer stack, POP+CALL à la sortie du scope
# Émergence : INVERSER le moment de MESURE = exécuter à l'envers (en sortant)
# Utilisé pour : fermer fichiers, libérer ressources, cleanup
# Le bloc est exécuté quand le scope englobant se termine (LIFO)
# Sucre : defer = !?
# Sucre : defer = !? (keyword → symbole)
DeferSugar       <- 'defer' ![a-zA-Z0-9_] Spacing Block
DeferStmt        <- '!?' Spacing Block

ExpressionStmt   <- Expression Semicolon

# ============================================================
#  EXPRESSIONS
# ============================================================

Expression       <- PipeExpr

# --- PIPE SPSC : parallélisme émergent (async, buffered) ---
PipeExpr         <- PassThroughExpr (Spacing '|' !'|' Spacing PassThroughExpr)*

# v6.0 NOUVEAU — pass-through : a >< b (sync, direct, sans buffer)
# >< en expression = ENTRER(SORTIR) = traverser
# Différence avec | :
#   a | b  = connecter a et b (async, SPSC ring buffer, green threads)
#   a >< b = a traverse b (sync, direct, même thread, transformation)
# Précédence : juste en-dessous de | (pipe)
PassThroughExpr  <- RangeExpr (Spacing '><' Spacing RangeExpr)*

# v6.0 FIX — range comme opérateur infixe (plus dans PrimaryExpr)
# a..b = range de a à b (optionnel, pas chaînable)
# Précédence basse : au-dessus de broadcast, en-dessous de pass-through
# Pour open ranges : a..* (a vers any), *..b (any vers b, rare)
# SliceAccess gère les ranges dans [] : list[a..b]
RangeExpr        <- BroadcastExpr (Spacing '..' Spacing BroadcastExpr)?

# --- BROADCAST SPMC : diffusion 1→N ---
BroadcastExpr    <- MeasureExpr (Spacing '~' Spacing MeasureExpr)?

# --- MESURE : ? et ?? (le cœur du langage) ---
MeasureExpr      <- LogicalOrExpr (Spacing MeasureSuffix)?

MeasureSuffix    <- ContinuousMeasure
                  / SingleMeasure
                  / MeasureBlock

# Mesure anonyme (? sans bloc) autorisée
SingleMeasure    <- '?' !'?' Spacing MeasureBlock?

ContinuousMeasure <- '??' Spacing MeasureBlock

MeasureBlock     <- '{' Spacing MeasureBranch+ Spacing '}'

MeasureBranch    <- SpinBranch
                  / ConditionBranch
                  / WildcardBranch

# SpinBranch avec MatchBody (destructuring de variants)
SpinBranch       <- SpinPattern Spacing MatchBody? Spacing
                    FilterExpr? Spacing ':' Spacing BranchBody
                  / Binding Spacing FilterExpr? Spacing ':'
                    Spacing BranchBody

MatchBody        <- VariantMatch
                  / StringLiteral
                  / NumberLiteral
                  / Binding

VariantMatch     <- Identifier ('(' Spacing BindingList? Spacing ')')?

BindingList      <- Binding (Spacing ',' Spacing Binding)*

ConditionBranch  <- '(' Spacing Expression Spacing ')' Spacing ':'
                    Spacing BranchBody

WildcardBranch   <- '_' Spacing ':' Spacing BranchBody

SpinPattern      <- '+' / '-' / '*' / '#'

Binding          <- Identifier '?'

FilterExpr       <- '(' Spacing Expression Spacing ')'

# BranchBody utilise BlockExpr
# Permet : + : { y = 5; y + 1 }  (statements + expression finale)
# Et aussi : + : expr;            (expression simple avec ;)
BranchBody       <- BlockExpr / Expression Semicolon

# Block = alias pour BlockExpr (compatibilité interne)
Block            <- BlockExpr

# ============================================================
#  OPÉRATEURS (par précédence croissante)
# ============================================================

LogicalOrExpr    <- LogicalAndExpr (Spacing '||' Spacing LogicalAndExpr)*
LogicalAndExpr   <- QuantumExpr (Spacing '&&' Spacing QuantumExpr)*
# | est le pipe, pas bitwise OR → bitwise OR via bits::or()
# v8.0 : ^ libéré pour QPU → XOR bitwise via bits::xor()
# QuantumExpr remplace BitwiseXorExpr dans la chaîne de précédence
# Note : ^^ (QuantumMeasure) est géré dans UnaryExpr, pas ici.
# Ce niveau de précédence est réservé pour de futures extensions quantiques infixes.
QuantumExpr      <- BitwiseAndExpr
BitwiseAndExpr   <- EqualityExpr (Spacing '&' !'&' Spacing EqualityExpr)*
EqualityExpr     <- ComparisonExpr (Spacing EqOp Spacing ComparisonExpr)*
ComparisonExpr   <- ShiftExpr (Spacing CmpOp Spacing ShiftExpr)*
ShiftExpr        <- AdditiveExpr (Spacing ShiftOp Spacing AdditiveExpr)*
AdditiveExpr     <- MultiplicativeExpr (Spacing AddOp Spacing MultiplicativeExpr)*
MultiplicativeExpr <- UnaryExpr (Spacing MulOp Spacing UnaryExpr)*

# Ordre de précédence unaire :
#   1. UnaryOp (!, -, +) → classique
#   2. CopyExpr (**) → deep copy
#   3. SpinExpr (*, #) → constructeur variant
#   4. PostfixExpr → tout le reste
# v8.0 : QuantumMeasure (^^) ajouté avant CopyExpr
# Ordre de précédence unaire :
#   0. QuantumMeasure (^^) → collapse
#   1. FormatExpr (%"") → printf émergent
#   2. NormalizeExpr (%%) → normaliser
#   3. UnaryOp (!, -, +) → classique
#   4. CopyExpr (**) → deep copy
#   5. SpinExpr (*, #) → constructeur variant
#   6. PostfixExpr → tout le reste
UnaryExpr        <- QuantumMeasure
                  / FormatExpr
                  / NormalizeExpr
                  / UnaryOp Spacing UnaryExpr
                  / CopyExpr
                  / SpinExpr
                  / PostfixExpr

# ** pour copie profonde (remplace copy())
CopyExpr         <- '**' Spacing UnaryExpr

# CP-1 : FormatExpr = %"pattern" = PROPORTIONNER(TEXTE) = printf émergent
# %"valeur: $x"  → formater la string selon le pattern
# %%expr         → normaliser expr (double proportion)
FormatExpr       <- '%' Spacing StringLiteral
NormalizeExpr    <- '%%' Spacing UnaryExpr

# Expressions avec spin préfixe (constructeurs de variantes)
# * Leaf → variante any
# # Error("msg") → variante erreur
# + et - sont gérés par UnaryOp
SpinExpr         <- ('*' !'=' !'*' / '#') Spacing PostfixExpr

PostfixExpr      <- PrimaryExpr (Spacing Postfix)*

Postfix          <- DotAccess
                  / DotMeasure
                  / FunctionCall
                  / IndexAccess
                  / SliceAccess
                  / InlineMeasureBlock
                  / CompoundAssign
                  / CastExpr
                  / BorrowSuffix

DotAccess        <- '.' !'.' !'?' Identifier
# v6.0 NOTE : ParentAccess (..) est dans PrimaryExpr (prefix), pas Postfix
# Car en Postfix, a..b serait ambigu avec range (a..b)
# Solution : ..field est un PrimaryExpr (prefix), a..b est RangeExpr (infix)
DotMeasure       <- '.?' Spacing MeasureBlock?
FunctionCall     <- '(' Spacing ArgList? Spacing ')'
IndexAccess      <- '[' Spacing Expression Spacing ']'
SliceAccess      <- '[' Spacing Expression? Spacing '..' Spacing Expression? Spacing ']'
InlineMeasureBlock <- MeasureBlock
CompoundAssign   <- AssignOp Spacing Expression

# :> remplace 'as'
# Pas de Spacing initial : PostfixExpr gère déjà le spacing avant chaque Postfix
CastExpr         <- ':>' Spacing TypeExpr

# ============================================================
#  EXPRESSIONS PRIMAIRES
# ============================================================

# BlockExpr en premier — {} comme expression universelle
# Un bloc retourne la valeur de sa dernière expression
# Combinable avec tout : << {}, ** {}, x = {}, | {} etc.
PrimaryExpr      <- BlockExpr
                  / GroupExpr
                  / FunctionLiteral
                  / ListLiteral
                  / MapLiteral
                  / ParentAccessExpr
                  / ProbLiteral
                  / NumberLiteral
                  / StringLiteral
                  / RawStringLiteral
                  / StructLiteral
                  / CopyExprParen
                  / ModulePath
                  / SpinLiteral
                  / Identifier

# Bloc comme expression (conteneur universel)
# Le bloc retourne la valeur de sa dernière expression
# Si la dernière instruction n'est pas une expression, retourne _ (void)
BlockExpr        <- '{' Spacing (Statement Spacing)* Expression? Spacing '}'

GroupExpr        <- '(' Spacing Expression Spacing ')'

FunctionLiteral  <- '(' Spacing ParamList? Spacing ')'
                    (Spacing ':' Spacing TypeExpr)?
                    Spacing Block

ParamList        <- Param (Spacing ',' Spacing Param)*
Param            <- Identifier Spacing (':' Spacing TypeExpr)?

ListLiteral      <- '[' Spacing (Expression (Spacing ',' Spacing Expression)*)? Spacing ']'

MapLiteral       <- '[' Spacing MapEntry (Spacing ',' Spacing MapEntry)* Spacing ']'
MapEntry         <- Expression Spacing ':' Spacing Expression

# v6.0 NOUVEAU — ..field = accéder au scope parent
# Prefix uniquement (pas postfix, pour éviter le conflit avec range a..b)
# .. seul (sans identifier) = l'objet parent lui-même
# ..field = le champ 'field' du scope parent
# Analogue à 'cd ..' dans un filesystem
ParentAccessExpr <- '..' Identifier?

ProbLiteral      <- FloatLiteral 'p'

# **(expr) aussi valide comme alternative fonctionnelle
CopyExprParen    <- '**' '(' Spacing Expression Spacing ')'

# v6.0 — spin comme valeur littérale + sucre syntaxique
# Atomes spin (les 5 spins possibles) :
#   + = positif (true, succès)
#   - = négatif (false, échec)
#   * = any/tout (wildcard, tout est possible)
#   # = erreur (corruption, overflow)
#   _ = void (rien, vide, ignorer)
# Sucre optionnel :
#   true  → +
#   false → -
#   any   → *   (v6.0 NOUVEAU)
#   void  → _   (v6.0 : maps to _ maintenant, plus *)
SpinLiteral      <- '+' !'+'
                  / '-' !'-'
                  / '*' !'*'
                  / '#'
                  / '_' ![a-zA-Z0-9_]
                  / 'true' ![a-zA-Z0-9_]
                  / 'false' ![a-zA-Z0-9_]
                  / 'void' ![a-zA-Z0-9_]
                  / 'any' ![a-zA-Z0-9_]

# Struct literal : Type { champ: valeur, ... }
StructLiteral    <- TypePath Spacing '{' Spacing FieldInit
                    (Spacing ',' Spacing FieldInit)* Spacing '}'
FieldInit        <- Identifier Spacing ':' Spacing Expression

# ============================================================
#  TYPES
# ============================================================

TypeExpr         <- FunctionType / TupleType / SpinReturnType / SimpleType / BorrowType
SimpleType       <- TypePath GenericArgs?
GenericArgs      <- '(' Spacing TypeList Spacing ')'
FunctionType     <- '(' Spacing TypeList? Spacing ')' Spacing ':' Spacing TypeExpr
TupleType        <- '(' Spacing TypeExpr Spacing ',' Spacing TypeList Spacing ')'
TypePath         <- Identifier ('::' Identifier)*
TypeList         <- TypeExpr (Spacing ',' Spacing TypeExpr)*

# Type de retour multi-spin
# Déclare les spins possibles : +Result | -Error | #Critical
SpinReturnType   <- SpinPattern? SimpleType (Spacing '|' Spacing SpinPattern? SimpleType)*

# Type avec emprunt pour les signatures
BorrowType       <- SimpleType ('@@' / '@')

# ============================================================
#  OPÉRATEURS — TERMINAUX
# ============================================================

EqOp             <- '==' / '!='
CmpOp            <- '<=' / '>=' / '<' !'<' / '>' !'>'
# ShiftOp : << (shift left) et >> (shift right)
# v6.0 : << en statement = return (ReturnStmt, testé AVANT ExpressionStmt)
# v7.0 : >> en statement = continue (ContinueStmt, testé AVANT ExpressionStmt)
#         >> en expression (entre deux valeurs) = shift right (inchangé)
#         Clé : ContinueStmt <- '>>' !'=' ... essayé AVANT ExpressionStmt
#               >>= reste un AssignOp (shift-assign), d'où le !'='
ShiftOp          <- '<<' / '>>' !'='
# ++ pour concaténation, testé avant + et -
AddOp            <- '++' / '+' !'+' / '-' !'-'
# * ne matche PAS ** (pour ne pas confondre avec copy)
# CP-1 : % = boson PROPORTIONNER mais reste dans MulOp en infixe
# (comme + est boson ACCUMULER mais reste dans AddOp en infixe)
# % en infixe = modulo (proportion). % en préfixe/composition = autres sens.
# %% = normaliser, %? = probabilité, %"fmt" = format string (émergent)
MulOp            <- '*' !'=' !'*' / '/' / '%'
# Unaire : !, -, + (spin + et - aussi via UnaryOp, le type system résout)
UnaryOp          <- '!' / '-' !'-' / '+' !'+'
# v8.0 : ^= retiré (^ = QPU, plus XOR)
AssignOp         <- '+=' / '-=' / '*=' / '/=' / '%='
                  / '&=' / '<<=' / '>>='

# ============================================================
#  LEXÈMES (tokens)
# ============================================================

# v7.0 : Keywords = 2 base + 6 sucre
Identifier       <- !Keyword [a-zA-Z_] [a-zA-Z0-9_]*

# Keywords protégés :
#   type, trait = fondamentaux (concepts math universels, irremplaçables)
#   true, false, void, any = sucre spin (alias pour +, -, _, *)
#   continue, defer = sucre contrôle (alias pour >>, !?)
Keyword          <- ('type' / 'trait' / 'true' / 'false' / 'void' / 'any'
                  / 'continue' / 'defer') ![a-zA-Z0-9_]

ModulePath       <- Identifier ('::' Identifier)*

IdentList        <- Identifier (Spacing ',' Spacing Identifier)*

# Arguments avec support des arguments nommés
ArgList          <- Arg (Spacing ',' Spacing Arg)*
Arg              <- NamedArg / Expression
NamedArg         <- Identifier Spacing ':' Spacing Expression

BorrowSuffix     <- '@@' / '@'

# ============================================================
#  LITTÉRAUX
# ============================================================

NumberLiteral    <- HexLiteral / BinLiteral / TernLiteral / FloatLiteral / IntLiteral

IntLiteral       <- [0-9] [0-9_]*
FloatLiteral     <- [0-9] [0-9_]* '.' [0-9] [0-9_]*
HexLiteral       <- '0x' [0-9a-fA-F] [0-9a-fA-F_]*
BinLiteral       <- '0b' [01] [01_]*
TernLiteral      <- '0t' [012] [012_]*

# CP-1 : interpolation via $ (plus explicite que {})
# "hello $name"        → interpolation simple (identifiant)
# "hello ${expr + 1}"  → interpolation complexe (expression)
# "literal \$"         → échapper le $ (littéral)
# $?name dans string   → conditionnel (inclure si pas void)
# $!name dans string   → échapper/raw (pas d'interp)
StringLiteral    <- '"' StringChar* '"'
# $ suivi de { = interpolation complexe (${expr})
# $ suivi d'identifier = interpolation simple ($name)
# $ seul (fin de string, suivi de " ou espace) = littéral $
# \$ = échapper le $ explicitement
StringChar       <- '\\' EscapeChar
                  / '$' '{' Spacing Expression Spacing '}'
                  / '$' &[a-zA-Z_] Identifier
                  / '$' !'{' ![a-zA-Z_]
                  / !'"' .

EscapeChar       <- 'n' / 't' / 'r' / '\\' / '"' / '0' / '$'

# v7.0 NOUVEAU — '' = texte brut (gluon, pas d'interpolation ni d'escape)
# Différence avec "" :
#   "hello {name}\n"  → interpolation + escape sequences
#   'hello {name}\n'  → littéral brut, {name} et \n restent tels quels
# Utile pour : regex, chemins Windows, templates, SQL, shell
# Analogue au single-quote en bash : pas d'expansion
RawStringLiteral <- ['] RawStringChar* [']
RawStringChar    <- !['] .

# ============================================================
#  ESPACES ET COMMENTAIRES
#  CP-2 : Les commentaires ÉMERGENT du boson / (DIVISER)
#  // = DIVISER(DIVISER) = double séparation = séparer du code
#  /* */ = DIVISER + gluon * = section séparée avec délimiteurs
#  Le parsing les traite comme espaces (le code séparé n'existe plus)
# ============================================================

Spacing          <- (Whitespace / Comment)*
Whitespace       <- [ \t\r\n]+
Comment          <- LineComment / BlockComment
LineComment      <- '//' (![\\r\\n] .)* [\\r\\n]?
BlockComment     <- '/*' (!'*/' .)* '*/'

Semicolon        <- Spacing ';'
EOF              <- !.

# ============================================================
#  NOTES DE DESIGN v6.0
# ============================================================
#
#  PARADIGME : Fractal Composition
#  ================================
#
#  Le langage 3.42 n'a PAS de syntaxe traditionnelle.
#  Il a 18 verbes (atomes) et UNE règle : A(B) = "A appliqué à B".
#  Tout le reste — return, break, if, while, pipe, thread — ÉMERGE.
#
#  AST = 3 types de nœuds :
#    Atom(symbol)               — un seul atome
#    Compose(ASTNode, ASTNode)  — A appliqué à B
#    Sphere(spin, value, children) — une sphère avec état
#
#  DISAMBIGUATION v6.0 :
#
#  1. << (return vs shift left)
#     Statement level : ReturnStmt <- '<<' ... essayé AVANT ExpressionStmt
#     Expression level : ShiftOp <- '<<' (entre deux expressions)
#     Clé : PEG ordered choice dans Statement alternatives
#
#  2. >< (break vs pass-through)
#     Statement level : BreakStmt <- '><' SpinReturn? Expression? Semicolon
#     Expression level : PassThroughExpr <- a >< b (infixe entre expressions)
#     Clé : BreakStmt essayé AVANT ExpressionStmt.
#           En début de statement, >< suivi de ; ou spin = break.
#           En expression (entre deux valeurs), >< = pass-through.
#     Note : PipeExpr contient PassThroughExpr, donc a >< b est parsé
#            comme expression avant d'atteindre Statement level.
#
#  3. >> (continue vs shift right)
#     v5.1 : >> = break. v6.0 : >> libéré. v7.0 : >> = continue.
#     Statement level : ContinueStmt <- '>>' !'=' SpinReturn? Expression? Semicolon
#     Expression level : ShiftOp <- '>>' !'=' (entre deux expressions)
#     Clé : ContinueStmt essayé AVANT ExpressionStmt.
#           >> en début de statement = continue (re-entrer la boucle).
#           >> entre deux valeurs (a >> b) = shift right.
#           >>= reste un CompoundAssign (shift-assign).
#
#  4. ~ (mut vs broadcast)
#     Statement level : MutDecl <- '~' Spacing Assignment
#     Expression level : BroadcastExpr <- MeasureExpr '~' MeasureExpr (infixe)
#     Clé : MutDecl essayé avant ExpressionStmt. ~ en début + Assignment = mut.
#
#  5. + - (spin literal vs unaire vs addition)
#     Primaire (seul) : SpinLiteral <- '+' !'+'  (dans PrimaryExpr)
#     Préfixe : UnaryOp <- '+' !'+' (dans UnaryExpr, essayé AVANT PostfixExpr)
#     Infixe : AddOp <- '+' !'+' (dans AdditiveExpr, ENTRE deux expressions)
#     Clé : UnaryOp échoue si + n'est pas suivi d'expression → fallback SpinLiteral
#
#  6. * (any vs multiplication vs copy vs variant)
#     ** expr : CopyExpr <- '**' (essayé en premier dans UnaryExpr)
#     * expr : SpinExpr <- '*' !'=' !'*' (essayé après CopyExpr)
#     a * b : MulOp <- '*' !'=' !'*' (infixe, ENTRE deux expressions)
#     * seul : SpinLiteral <- '*' !'*' (dans PrimaryExpr, dernier recours)
#     *= : CompoundAssign (postfixe, '*=' testé comme AssignOp)
#
#  7. _ (void literal vs wildcard)
#     En MeasureBranch : WildcardBranch <- '_' ':' ... (catch-all dans ? {})
#     En Expression : SpinLiteral <- '_' ![a-zA-Z0-9_] (void value)
#     Clé : contextes différents (MeasureBranch vs PrimaryExpr)
#     Note : _foo reste un identifiant valide (_ suivi de chars = pas SpinLiteral)
#
#  8. :: (module decl vs path)
#     Statement : ModuleDecl <- '::' Identifier '{' ... (début de statement)
#     Expression : ModulePath <- Identifier '::' Identifier (ENTRE identifiers)
#
#  9. . vs .. (access vs parent vs range)
#     DotAccess <- '.' !'.' !'?' Identifier (Postfix, un seul point)
#     ParentAccessExpr <- '..' Identifier? (PrimaryExpr, prefix)
#     RangeExpr <- expr '..' expr (infixe, entre PassThrough et Broadcast)
#     Clé : DotAccess négate '..' via !'.' → pas d'ambiguïté.
#           ParentAccessExpr est PrimaryExpr (prefix, pas de left operand).
#           RangeExpr est infixe (a left operand, entre deux BroadcastExpr).
#           Donc ..field = parent access, a..b = range. Zéro conflit.
#
#  10. :> (cast — aucun conflit)
#     Postfixe : CastExpr <- ':>' TypeExpr
#     Aucun autre opérateur ne commence par :>
#
#  11. !? (defer — v7.0)
#     Statement level : DeferStmt <- '!?' Block
#     Expression level : '!' est UnaryOp, '?' est MeasureSuffix
#     Clé : '!?' est un token de 2 chars, testé comme Statement AVANT ExpressionStmt.
#           DeferStmt exige un Block ({}) après !?, pas une expression.
#           !expr et expr? restent inchangés (UnaryOp et MeasureSuffix).
#           Pas de conflit : !? est toujours suivi de { (Block).
#
#  12. '' (raw string — v7.0)
#     RawStringLiteral <- ['] RawStringChar* [']
#     StringLiteral <- '"' StringChar* '"'
#     Clé : caractère délimiteur différent (' vs "). Zéro conflit.
#           '' = texte brut (pas d'interpolation, pas d'escape).
#           "" = texte avec interpolation ({expr}) et escape (\n, \t, etc.).
#
#  13. ^ (quantum — v8.0)
#     Statement level : QuantumBlock <- '^' '{' ... '}' (bloc quantique)
#     Expression level : QuantumMeasure <- '^^' UnaryExpr (collapse)
#     Clé : QuantumBlock essayé AVANT ExpressionStmt.
#           ^{} = superposition (Statement), ^^ = mesure (UnaryExpr).
#           XOR bitwise → bits::xor() (libère ^ totalement).
#           '^' seul suivi de '{' = QuantumBlock. '^^' = mesure.
#           Aucun conflit : ^ n'est plus opérateur infixe.
#
#  14. % (proportion — CP-1)
#     Infixe : MulOp <- ... / '%' (entre deux expressions = modulo)
#     Préfixe : FormatExpr <- '%' StringLiteral (format string)
#     Préfixe : NormalizeExpr <- '%%' UnaryExpr (normaliser)
#     Clé : % suivi de " = FormatExpr (testé dans UnaryExpr AVANT PostfixExpr).
#           %% = NormalizeExpr (testé avant).
#           % entre deux valeurs (a % b) = MulOp = modulo.
#           Comme + : boson ET opérateur arithmétique selon contexte.
#
#  15. $ (interpolation — CP-1)
#     UNIQUEMENT dans les strings "" (pas un opérateur global).
#     "$name" = interpolation simple (identifier après $)
#     "${expr}" = interpolation complexe (expression dans ${})
#     "\$" = échapper le $ (littéral)
#     Clé : $ n'existe QUE dans StringChar. Pas d'ambiguïté globale.
#           En dehors des strings, $ n'a pas de sens syntaxique.
#
#  16. / (diviser — CP-2)
#     Infixe : MulOp <- ... / '/' (entre deux expressions = division)
#     Commentaire : '//' = DIVISER(DIVISER) = séparer du code (parsé dans Spacing)
#     Commentaire bloc : '/*' ... '*/' = DIVISER + gluon (parsé dans Spacing)
#     Clé : // et /* sont consommés par Spacing AVANT que l'expression parser les voie.
#           / seul entre deux expressions = MulOp = division.
#           Comme % : boson ET opérateur arithmétique selon contexte.
#           Les commentaires ÉMERGENT de la composition / + / et / + gluon.
#
#  MULTI-SPIN RETURN, BREAK, CONTINUE :
#  ======================================
#
#  ReturnStmt   <- '<<' SpinReturn? Expression?
#  BreakStmt    <- '><' SpinReturn? Expression?
#  ContinueStmt <- '>>' SpinReturn? Expression?
#  DeferStmt    <- '!?' Block
#  SpinReturn   <- SpinPattern !'='
#
#  << + expr;  → retourne expr avec spin + (succès)
#  << - expr;  → retourne expr avec spin - (échec)
#  << _ ;      → retourne void (spin _)
#  << # expr;  → retourne expr avec spin # (erreur)
#  << expr;    → retourne expr avec spin + (défaut)
#
#  >< ;        → break simple (quitter le contexte)
#  >< + val;   → break avec valeur positive
#  >< # err;   → break avec erreur
#
#  >> ;        → continue (skip to next iteration)
#  >> + ;      → continue avec signal positif
#
#  !? { cleanup(); };  → defer (exécuté à la sortie du scope, LIFO)
#
#  SPIN LITERALS CP-1 :
#  ======================
#
#  4 SPINS RÉELS (2 bits hardware) :
#  + = positif (true, success)        → bits 00
#  - = négatif (false, failure)       → bits 01
#  # = erreur (error, corrupt)        → bits 10
#  _ = void (rien, vide, ignorer)     → bits 11
#
#  * = PAS un 5ème spin. C'est le boson TRANSFORMER.
#  En pattern matching, * signifie "match any spin" = OR mask = don't care.
#  En expression, * = constructeur wildcard variant.
#  La distinction : 4 spins = états hardware (2 bits), * = méta-flag logiciel.
#
#  Sucre spin  : true(+), false(-), any(*), void(_)
#  Sucre ctrl  : continue(>>), defer(!?)
#
#  x = +;     → x est positif
#  y = _;     → y est void
#  z = *;     → z est any (wildcard)
#  flag = -;  → flag est négatif (false)
#
#  STRING LITERALS CP-1 :
#  =======================
#
#  "" = string interpolée (gluon avec expansion)
#       "hello $name\n"   → interpolation via $ + escape
#       "calc: ${x + 1}"  → interpolation complexe via ${}
#       "literal \$"      → $ échappé
#  '' = raw string (gluon brut, pas d'expansion)
#       'hello $name\n'   → texte littéral tel quel (pas d'interp)
#  %"" = format string (émergent, PROPORTIONNER + TEXTE)
#       %"valeur: $x"     → printf émergent
#
#  PASS-THROUGH vs PIPE :
#  =======================
#
#  a | b   = CONNECTER(a, b) = pipe async, buffered, green threads
#  a >< b  = ENTRER(SORTIR)(a, b) = pass-through sync, direct, même thread
#
#  Pipe crée un canal SPSC avec ring buffer entre deux green threads.
#  Pass-through appelle directement, transformation synchrone.
#
#  data | transform | output;      // 3 green threads, 2 buffers
#  data >< transform >< output;   // 1 thread, 0 buffer, appels directs
#
